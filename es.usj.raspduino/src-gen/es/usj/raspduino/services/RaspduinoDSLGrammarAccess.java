/*
* generated by Xtext
*/
package es.usj.raspduino.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class RaspduinoDSLGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSketchKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cHardwareKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cHardwareAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Alternatives cHardwareAlternatives_3_0 = (Alternatives)cHardwareAssignment_3.eContents().get(0);
		private final Keyword cHardwareArduinoUNOKeyword_3_0_0 = (Keyword)cHardwareAlternatives_3_0.eContents().get(0);
		private final Keyword cHardwareRaspberryPiKeyword_3_0_1 = (Keyword)cHardwareAlternatives_3_0.eContents().get(1);
		private final Assignment cDevicesAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cDevicesAbstractDeviceParserRuleCall_4_0 = (RuleCall)cDevicesAssignment_4.eContents().get(0);
		private final Assignment cEventHandlersAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cEventHandlersEventHandlerParserRuleCall_5_0 = (RuleCall)cEventHandlersAssignment_5.eContents().get(0);
		private final Assignment cSensorListenersAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cSensorListenersSensorListenerParserRuleCall_6_0 = (RuleCall)cSensorListenersAssignment_6.eContents().get(0);
		private final Assignment cTimersAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cTimersTimerParserRuleCall_7_0 = (RuleCall)cTimersAssignment_7.eContents().get(0);
		
		//// Definicion de las condiciones para ejecutar una tarea
		/// *(alarms+=Alarm)* / // TODO: En caso de conflicto definimos quien tiene preferencia, lo que indican los sensores o lo programado
		//// ('Concurrency Priority:' priority=('SENSOR'|'SCHEDULED'))*
		//Model: // Nombre y plataforma que utilizaremos
		//	"Sketch:" name=ID "Hardware:" hardware=("Arduino UNO" //Se podran añadir mas plataformas ARDUINO MEGA, NANO, etc.
		//	| "Raspberry Pi") // Sensores y actuadores que utilizaremos para nuestro diseño
		//	devices+=AbstractDevice* // Definicion de tareas o eventos
		//	eventHandlers+=EventHandler* // Definicion de las condiciones para ejecutar una tarea
		//	sensorListeners+=SensorListener* // Definicion de las condiciones para ejecutar una tarea
		//	timers+=Timer*;
		public ParserRule getRule() { return rule; }

		//// Nombre y plataforma que utilizaremos
		//"Sketch:" name=ID "Hardware:" hardware=("Arduino UNO" //Se podran añadir mas plataformas ARDUINO MEGA, NANO, etc.
		//| "Raspberry Pi") // Sensores y actuadores que utilizaremos para nuestro diseño
		//devices+=AbstractDevice* // Definicion de tareas o eventos
		//eventHandlers+=EventHandler* // Definicion de las condiciones para ejecutar una tarea
		//sensorListeners+=SensorListener* // Definicion de las condiciones para ejecutar una tarea
		//timers+=Timer*
		public Group getGroup() { return cGroup; }

		//// Nombre y plataforma que utilizaremos
		//"Sketch:"
		public Keyword getSketchKeyword_0() { return cSketchKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"Hardware:"
		public Keyword getHardwareKeyword_2() { return cHardwareKeyword_2; }

		//hardware=("Arduino UNO" //Se podran añadir mas plataformas ARDUINO MEGA, NANO, etc.
		//| "Raspberry Pi")
		public Assignment getHardwareAssignment_3() { return cHardwareAssignment_3; }

		//"Arduino UNO" //Se podran añadir mas plataformas ARDUINO MEGA, NANO, etc.
		//| "Raspberry Pi"
		public Alternatives getHardwareAlternatives_3_0() { return cHardwareAlternatives_3_0; }

		//"Arduino UNO"
		public Keyword getHardwareArduinoUNOKeyword_3_0_0() { return cHardwareArduinoUNOKeyword_3_0_0; }

		//"Raspberry Pi"
		public Keyword getHardwareRaspberryPiKeyword_3_0_1() { return cHardwareRaspberryPiKeyword_3_0_1; }

		//devices+=AbstractDevice*
		public Assignment getDevicesAssignment_4() { return cDevicesAssignment_4; }

		//AbstractDevice
		public RuleCall getDevicesAbstractDeviceParserRuleCall_4_0() { return cDevicesAbstractDeviceParserRuleCall_4_0; }

		//eventHandlers+=EventHandler*
		public Assignment getEventHandlersAssignment_5() { return cEventHandlersAssignment_5; }

		//EventHandler
		public RuleCall getEventHandlersEventHandlerParserRuleCall_5_0() { return cEventHandlersEventHandlerParserRuleCall_5_0; }

		//sensorListeners+=SensorListener*
		public Assignment getSensorListenersAssignment_6() { return cSensorListenersAssignment_6; }

		//SensorListener
		public RuleCall getSensorListenersSensorListenerParserRuleCall_6_0() { return cSensorListenersSensorListenerParserRuleCall_6_0; }

		//timers+=Timer*
		public Assignment getTimersAssignment_7() { return cTimersAssignment_7; }

		//Timer
		public RuleCall getTimersTimerParserRuleCall_7_0() { return cTimersTimerParserRuleCall_7_0; }
	}

	public class AbstractDeviceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AbstractDevice");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSensorParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cActuatorParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// Definicion de los sensore y actuadores SENSOR:INPUT ACUATOR:OUTPUT
		//AbstractDevice:
		//	Sensor | Actuator;
		public ParserRule getRule() { return rule; }

		//Sensor | Actuator
		public Alternatives getAlternatives() { return cAlternatives; }

		//Sensor
		public RuleCall getSensorParserRuleCall_0() { return cSensorParserRuleCall_0; }

		//Actuator
		public RuleCall getActuatorParserRuleCall_1() { return cActuatorParserRuleCall_1; }
	}

	public class SensorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Sensor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSensorKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cPinKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cPinAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPinSTRINGTerminalRuleCall_3_0 = (RuleCall)cPinAssignment_3.eContents().get(0);
		
		//Sensor:
		//	"Sensor" name=ID "pin" pin= //(analog?='analog')? ';'
		//	STRING;
		public ParserRule getRule() { return rule; }

		//"Sensor" name=ID "pin" pin= //(analog?='analog')? ';'
		//STRING
		public Group getGroup() { return cGroup; }

		//"Sensor"
		public Keyword getSensorKeyword_0() { return cSensorKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"pin"
		public Keyword getPinKeyword_2() { return cPinKeyword_2; }

		//pin= //(analog?='analog')? ';'
		//STRING
		public Assignment getPinAssignment_3() { return cPinAssignment_3; }

		////(analog?='analog')? ';'
		//STRING
		public RuleCall getPinSTRINGTerminalRuleCall_3_0() { return cPinSTRINGTerminalRuleCall_3_0; }
	}

	public class ActuatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Actuator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cActuatorKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cPinKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cPinAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPinSTRINGTerminalRuleCall_3_0 = (RuleCall)cPinAssignment_3.eContents().get(0);
		
		//Actuator:
		//	"Actuator" name=ID "pin" pin=STRING;
		public ParserRule getRule() { return rule; }

		//"Actuator" name=ID "pin" pin=STRING
		public Group getGroup() { return cGroup; }

		//"Actuator"
		public Keyword getActuatorKeyword_0() { return cActuatorKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"pin"
		public Keyword getPinKeyword_2() { return cPinKeyword_2; }

		//pin=STRING
		public Assignment getPinAssignment_3() { return cPinAssignment_3; }

		//STRING
		public RuleCall getPinSTRINGTerminalRuleCall_3_0() { return cPinSTRINGTerminalRuleCall_3_0; }
	}

	public class EventHandlerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EventHandler");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEventHandlerKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cChangeActuatorsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cChangeActuatorsChangeActuatorParserRuleCall_2_0 = (RuleCall)cChangeActuatorsAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// Definimos que acciones realizaran los actuadores en cada tarea
		//EventHandler:
		//	"EventHandler" name=ID changeActuators+=ChangeActuator* ";";
		public ParserRule getRule() { return rule; }

		//"EventHandler" name=ID changeActuators+=ChangeActuator* ";"
		public Group getGroup() { return cGroup; }

		//"EventHandler"
		public Keyword getEventHandlerKeyword_0() { return cEventHandlerKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//changeActuators+=ChangeActuator*
		public Assignment getChangeActuatorsAssignment_2() { return cChangeActuatorsAssignment_2; }

		//ChangeActuator
		public RuleCall getChangeActuatorsChangeActuatorParserRuleCall_2_0() { return cChangeActuatorsChangeActuatorParserRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class ChangeActuatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ChangeActuator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cActuatorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cActuatorActuatorCrossReference_0_0 = (CrossReference)cActuatorAssignment_0.eContents().get(0);
		private final RuleCall cActuatorActuatorIDTerminalRuleCall_0_0_1 = (RuleCall)cActuatorActuatorCrossReference_0_0.eContents().get(1);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cActuatorStateAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cActuatorStateAlternatives_2_0 = (Alternatives)cActuatorStateAssignment_2.eContents().get(0);
		private final Keyword cActuatorStateOnKeyword_2_0_0 = (Keyword)cActuatorStateAlternatives_2_0.eContents().get(0);
		private final Keyword cActuatorStateOffKeyword_2_0_1 = (Keyword)cActuatorStateAlternatives_2_0.eContents().get(1);
		private final Keyword cActuatorStateToggleKeyword_2_0_2 = (Keyword)cActuatorStateAlternatives_2_0.eContents().get(2);
		
		//ChangeActuator:
		//	actuator=[Actuator] ":" ActuatorState=("On" // Añadir mas opciones como Blink(tiempo)
		//	| "Off" | "Toggle");
		public ParserRule getRule() { return rule; }

		//actuator=[Actuator] ":" ActuatorState=("On" // Añadir mas opciones como Blink(tiempo)
		//| "Off" | "Toggle")
		public Group getGroup() { return cGroup; }

		//actuator=[Actuator]
		public Assignment getActuatorAssignment_0() { return cActuatorAssignment_0; }

		//[Actuator]
		public CrossReference getActuatorActuatorCrossReference_0_0() { return cActuatorActuatorCrossReference_0_0; }

		//ID
		public RuleCall getActuatorActuatorIDTerminalRuleCall_0_0_1() { return cActuatorActuatorIDTerminalRuleCall_0_0_1; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//ActuatorState=("On" // Añadir mas opciones como Blink(tiempo)
		//| "Off" | "Toggle")
		public Assignment getActuatorStateAssignment_2() { return cActuatorStateAssignment_2; }

		//"On" // Añadir mas opciones como Blink(tiempo)
		//| "Off" | "Toggle"
		public Alternatives getActuatorStateAlternatives_2_0() { return cActuatorStateAlternatives_2_0; }

		//"On"
		public Keyword getActuatorStateOnKeyword_2_0_0() { return cActuatorStateOnKeyword_2_0_0; }

		//"Off"
		public Keyword getActuatorStateOffKeyword_2_0_1() { return cActuatorStateOffKeyword_2_0_1; }

		//"Toggle"
		public Keyword getActuatorStateToggleKeyword_2_0_2() { return cActuatorStateToggleKeyword_2_0_2; }
	}

	public class SensorListenerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SensorListener");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSensorListenerKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSensorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cSensorSensorCrossReference_1_0 = (CrossReference)cSensorAssignment_1.eContents().get(0);
		private final RuleCall cSensorSensorIDTerminalRuleCall_1_0_1 = (RuleCall)cSensorSensorCrossReference_1_0.eContents().get(1);
		private final Keyword cIfKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Assignment cTypeAssignment_3_0 = (Assignment)cAlternatives_3.eContents().get(0);
		private final Keyword cTypeONKeyword_3_0_0 = (Keyword)cTypeAssignment_3_0.eContents().get(0);
		private final Assignment cTypeAssignment_3_1 = (Assignment)cAlternatives_3.eContents().get(1);
		private final Keyword cTypeOFFKeyword_3_1_0 = (Keyword)cTypeAssignment_3_1.eContents().get(0);
		private final Group cGroup_3_2 = (Group)cAlternatives_3.eContents().get(2);
		private final Assignment cTypeAssignment_3_2_0 = (Assignment)cGroup_3_2.eContents().get(0);
		private final Keyword cTypeBETWEENKeyword_3_2_0_0 = (Keyword)cTypeAssignment_3_2_0.eContents().get(0);
		private final Assignment cLAssignment_3_2_1 = (Assignment)cGroup_3_2.eContents().get(1);
		private final RuleCall cLINTTerminalRuleCall_3_2_1_0 = (RuleCall)cLAssignment_3_2_1.eContents().get(0);
		private final Keyword cANDKeyword_3_2_2 = (Keyword)cGroup_3_2.eContents().get(2);
		private final Assignment cHAssignment_3_2_3 = (Assignment)cGroup_3_2.eContents().get(3);
		private final RuleCall cHINTTerminalRuleCall_3_2_3_0 = (RuleCall)cHAssignment_3_2_3.eContents().get(0);
		private final Keyword cCallKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cEventHandlerAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final CrossReference cEventHandlerEventHandlerCrossReference_5_0 = (CrossReference)cEventHandlerAssignment_5.eContents().get(0);
		private final RuleCall cEventHandlerEventHandlerIDTerminalRuleCall_5_0_1 = (RuleCall)cEventHandlerEventHandlerCrossReference_5_0.eContents().get(1);
		
		//// Definimos las condiciones de los SensorListeners
		//SensorListener:
		//	"SensorListener" sensor=[Sensor] "if" (type="ON" // Mas posibilidades (type='CHANGE' | type='RISING' | type='FALLING' ) 
		//	| type="OFF" | type="BETWEEN" l=INT "AND" h=INT) "call" eventHandler=[EventHandler];
		public ParserRule getRule() { return rule; }

		//"SensorListener" sensor=[Sensor] "if" (type="ON" // Mas posibilidades (type='CHANGE' | type='RISING' | type='FALLING' ) 
		//| type="OFF" | type="BETWEEN" l=INT "AND" h=INT) "call" eventHandler=[EventHandler]
		public Group getGroup() { return cGroup; }

		//"SensorListener"
		public Keyword getSensorListenerKeyword_0() { return cSensorListenerKeyword_0; }

		//sensor=[Sensor]
		public Assignment getSensorAssignment_1() { return cSensorAssignment_1; }

		//[Sensor]
		public CrossReference getSensorSensorCrossReference_1_0() { return cSensorSensorCrossReference_1_0; }

		//ID
		public RuleCall getSensorSensorIDTerminalRuleCall_1_0_1() { return cSensorSensorIDTerminalRuleCall_1_0_1; }

		//"if"
		public Keyword getIfKeyword_2() { return cIfKeyword_2; }

		//type="ON" // Mas posibilidades (type='CHANGE' | type='RISING' | type='FALLING' ) 
		//| type="OFF" | type="BETWEEN" l=INT "AND" h=INT
		public Alternatives getAlternatives_3() { return cAlternatives_3; }

		//type="ON"
		public Assignment getTypeAssignment_3_0() { return cTypeAssignment_3_0; }

		//"ON"
		public Keyword getTypeONKeyword_3_0_0() { return cTypeONKeyword_3_0_0; }

		//type="OFF"
		public Assignment getTypeAssignment_3_1() { return cTypeAssignment_3_1; }

		//"OFF"
		public Keyword getTypeOFFKeyword_3_1_0() { return cTypeOFFKeyword_3_1_0; }

		//type="BETWEEN" l=INT "AND" h=INT
		public Group getGroup_3_2() { return cGroup_3_2; }

		//type="BETWEEN"
		public Assignment getTypeAssignment_3_2_0() { return cTypeAssignment_3_2_0; }

		//"BETWEEN"
		public Keyword getTypeBETWEENKeyword_3_2_0_0() { return cTypeBETWEENKeyword_3_2_0_0; }

		//l=INT
		public Assignment getLAssignment_3_2_1() { return cLAssignment_3_2_1; }

		//INT
		public RuleCall getLINTTerminalRuleCall_3_2_1_0() { return cLINTTerminalRuleCall_3_2_1_0; }

		//"AND"
		public Keyword getANDKeyword_3_2_2() { return cANDKeyword_3_2_2; }

		//h=INT
		public Assignment getHAssignment_3_2_3() { return cHAssignment_3_2_3; }

		//INT
		public RuleCall getHINTTerminalRuleCall_3_2_3_0() { return cHINTTerminalRuleCall_3_2_3_0; }

		//"call"
		public Keyword getCallKeyword_4() { return cCallKeyword_4; }

		//eventHandler=[EventHandler]
		public Assignment getEventHandlerAssignment_5() { return cEventHandlerAssignment_5; }

		//[EventHandler]
		public CrossReference getEventHandlerEventHandlerCrossReference_5_0() { return cEventHandlerEventHandlerCrossReference_5_0; }

		//ID
		public RuleCall getEventHandlerEventHandlerIDTerminalRuleCall_5_0_1() { return cEventHandlerEventHandlerIDTerminalRuleCall_5_0_1; }
	}

	public class TimerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Timer");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTimerActionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cEventHandlerAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cEventHandlerEventHandlerCrossReference_1_0 = (CrossReference)cEventHandlerAssignment_1.eContents().get(0);
		private final RuleCall cEventHandlerEventHandlerIDTerminalRuleCall_1_0_1 = (RuleCall)cEventHandlerEventHandlerCrossReference_1_0.eContents().get(1);
		private final Keyword cRepeatKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRepeattypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Alternatives cRepeattypeAlternatives_3_0 = (Alternatives)cRepeattypeAssignment_3.eContents().get(0);
		private final Keyword cRepeattypeONCEKeyword_3_0_0 = (Keyword)cRepeattypeAlternatives_3_0.eContents().get(0);
		private final Keyword cRepeattypeEVERYKeyword_3_0_1 = (Keyword)cRepeattypeAlternatives_3_0.eContents().get(1);
		private final Keyword cSecondsKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cTimerSecsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cTimerSecsINTTerminalRuleCall_5_0 = (RuleCall)cTimerSecsAssignment_5.eContents().get(0);
		
		//// Acciones programadas para realizarse cada X segundos, o a determinadas horas del dia.
		//// IDEAS PARA CONTINUAR EL DESARROLLO
		/// *Alarm:
		//		'action' eventHandler=[EventHandler]
		//		'repeat' repeattype = ('EVERY DAY'|'EVERY MONDAY'|'EVERY TUESDAY'|'EVERY WEDNESDAY'
		//								|'EVERY THURSDAY'|'EVERY FRIDAY'|'EVERY SATURDAY'|'EVERY SUNDAY')
		//		'hours:' timerHours = INT
		//		'minutes:' timerMinutes = INT
		//	;* / / *
		//	 * // Condiciones establecidas para los valores
		//		Precondition:
		//			 pre1=Precondition1 op=('&&'|'||') pre=Precondition | pre1=Precondition1
		//		;
		//		Precondition1:
		//			(pre=SensorValuePrecondition | pre=EmptyPrecondition)
		//		;
		//		EmptyPrecondition:
		//			name=ID
		//		;
		//		SensorValuePrecondition:
		//			sensor=[Sensor] cond=('==' | '<=' | '>=' | '!=') value=PossibleValues 
		//		;
		//		PossibleValues:
		//			DOUBLE | INT
		//		;
		//		terminal DOUBLE: // TODO no se porque no me ha dejado poner el double
		//			INT'.'INT
		//		;
		//	 * / Timer:
		//	"Timer action" eventHandler=[EventHandler] "repeat" repeattype=("ONCE" | "EVERY") "seconds:" timerSecs=INT;
		public ParserRule getRule() { return rule; }

		//"Timer action" eventHandler=[EventHandler] "repeat" repeattype=("ONCE" | "EVERY") "seconds:" timerSecs=INT
		public Group getGroup() { return cGroup; }

		//"Timer action"
		public Keyword getTimerActionKeyword_0() { return cTimerActionKeyword_0; }

		//eventHandler=[EventHandler]
		public Assignment getEventHandlerAssignment_1() { return cEventHandlerAssignment_1; }

		//[EventHandler]
		public CrossReference getEventHandlerEventHandlerCrossReference_1_0() { return cEventHandlerEventHandlerCrossReference_1_0; }

		//ID
		public RuleCall getEventHandlerEventHandlerIDTerminalRuleCall_1_0_1() { return cEventHandlerEventHandlerIDTerminalRuleCall_1_0_1; }

		//"repeat"
		public Keyword getRepeatKeyword_2() { return cRepeatKeyword_2; }

		//repeattype=("ONCE" | "EVERY")
		public Assignment getRepeattypeAssignment_3() { return cRepeattypeAssignment_3; }

		//"ONCE" | "EVERY"
		public Alternatives getRepeattypeAlternatives_3_0() { return cRepeattypeAlternatives_3_0; }

		//"ONCE"
		public Keyword getRepeattypeONCEKeyword_3_0_0() { return cRepeattypeONCEKeyword_3_0_0; }

		//"EVERY"
		public Keyword getRepeattypeEVERYKeyword_3_0_1() { return cRepeattypeEVERYKeyword_3_0_1; }

		//"seconds:"
		public Keyword getSecondsKeyword_4() { return cSecondsKeyword_4; }

		//timerSecs=INT
		public Assignment getTimerSecsAssignment_5() { return cTimerSecsAssignment_5; }

		//INT
		public RuleCall getTimerSecsINTTerminalRuleCall_5_0() { return cTimerSecsINTTerminalRuleCall_5_0; }
	}
	
	
	private ModelElements pModel;
	private AbstractDeviceElements pAbstractDevice;
	private SensorElements pSensor;
	private ActuatorElements pActuator;
	private EventHandlerElements pEventHandler;
	private ChangeActuatorElements pChangeActuator;
	private SensorListenerElements pSensorListener;
	private TimerElements pTimer;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public RaspduinoDSLGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("es.usj.raspduino.RaspduinoDSL".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//// Definicion de las condiciones para ejecutar una tarea
	/// *(alarms+=Alarm)* / // TODO: En caso de conflicto definimos quien tiene preferencia, lo que indican los sensores o lo programado
	//// ('Concurrency Priority:' priority=('SENSOR'|'SCHEDULED'))*
	//Model: // Nombre y plataforma que utilizaremos
	//	"Sketch:" name=ID "Hardware:" hardware=("Arduino UNO" //Se podran añadir mas plataformas ARDUINO MEGA, NANO, etc.
	//	| "Raspberry Pi") // Sensores y actuadores que utilizaremos para nuestro diseño
	//	devices+=AbstractDevice* // Definicion de tareas o eventos
	//	eventHandlers+=EventHandler* // Definicion de las condiciones para ejecutar una tarea
	//	sensorListeners+=SensorListener* // Definicion de las condiciones para ejecutar una tarea
	//	timers+=Timer*;
	public ModelElements getModelAccess() {
		return (pModel != null) ? pModel : (pModel = new ModelElements());
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//// Definicion de los sensore y actuadores SENSOR:INPUT ACUATOR:OUTPUT
	//AbstractDevice:
	//	Sensor | Actuator;
	public AbstractDeviceElements getAbstractDeviceAccess() {
		return (pAbstractDevice != null) ? pAbstractDevice : (pAbstractDevice = new AbstractDeviceElements());
	}
	
	public ParserRule getAbstractDeviceRule() {
		return getAbstractDeviceAccess().getRule();
	}

	//Sensor:
	//	"Sensor" name=ID "pin" pin= //(analog?='analog')? ';'
	//	STRING;
	public SensorElements getSensorAccess() {
		return (pSensor != null) ? pSensor : (pSensor = new SensorElements());
	}
	
	public ParserRule getSensorRule() {
		return getSensorAccess().getRule();
	}

	//Actuator:
	//	"Actuator" name=ID "pin" pin=STRING;
	public ActuatorElements getActuatorAccess() {
		return (pActuator != null) ? pActuator : (pActuator = new ActuatorElements());
	}
	
	public ParserRule getActuatorRule() {
		return getActuatorAccess().getRule();
	}

	//// Definimos que acciones realizaran los actuadores en cada tarea
	//EventHandler:
	//	"EventHandler" name=ID changeActuators+=ChangeActuator* ";";
	public EventHandlerElements getEventHandlerAccess() {
		return (pEventHandler != null) ? pEventHandler : (pEventHandler = new EventHandlerElements());
	}
	
	public ParserRule getEventHandlerRule() {
		return getEventHandlerAccess().getRule();
	}

	//ChangeActuator:
	//	actuator=[Actuator] ":" ActuatorState=("On" // Añadir mas opciones como Blink(tiempo)
	//	| "Off" | "Toggle");
	public ChangeActuatorElements getChangeActuatorAccess() {
		return (pChangeActuator != null) ? pChangeActuator : (pChangeActuator = new ChangeActuatorElements());
	}
	
	public ParserRule getChangeActuatorRule() {
		return getChangeActuatorAccess().getRule();
	}

	//// Definimos las condiciones de los SensorListeners
	//SensorListener:
	//	"SensorListener" sensor=[Sensor] "if" (type="ON" // Mas posibilidades (type='CHANGE' | type='RISING' | type='FALLING' ) 
	//	| type="OFF" | type="BETWEEN" l=INT "AND" h=INT) "call" eventHandler=[EventHandler];
	public SensorListenerElements getSensorListenerAccess() {
		return (pSensorListener != null) ? pSensorListener : (pSensorListener = new SensorListenerElements());
	}
	
	public ParserRule getSensorListenerRule() {
		return getSensorListenerAccess().getRule();
	}

	//// Acciones programadas para realizarse cada X segundos, o a determinadas horas del dia.
	//// IDEAS PARA CONTINUAR EL DESARROLLO
	/// *Alarm:
	//		'action' eventHandler=[EventHandler]
	//		'repeat' repeattype = ('EVERY DAY'|'EVERY MONDAY'|'EVERY TUESDAY'|'EVERY WEDNESDAY'
	//								|'EVERY THURSDAY'|'EVERY FRIDAY'|'EVERY SATURDAY'|'EVERY SUNDAY')
	//		'hours:' timerHours = INT
	//		'minutes:' timerMinutes = INT
	//	;* / / *
	//	 * // Condiciones establecidas para los valores
	//		Precondition:
	//			 pre1=Precondition1 op=('&&'|'||') pre=Precondition | pre1=Precondition1
	//		;
	//		Precondition1:
	//			(pre=SensorValuePrecondition | pre=EmptyPrecondition)
	//		;
	//		EmptyPrecondition:
	//			name=ID
	//		;
	//		SensorValuePrecondition:
	//			sensor=[Sensor] cond=('==' | '<=' | '>=' | '!=') value=PossibleValues 
	//		;
	//		PossibleValues:
	//			DOUBLE | INT
	//		;
	//		terminal DOUBLE: // TODO no se porque no me ha dejado poner el double
	//			INT'.'INT
	//		;
	//	 * / Timer:
	//	"Timer action" eventHandler=[EventHandler] "repeat" repeattype=("ONCE" | "EVERY") "seconds:" timerSecs=INT;
	public TimerElements getTimerAccess() {
		return (pTimer != null) ? pTimer : (pTimer = new TimerElements());
	}
	
	public ParserRule getTimerRule() {
		return getTimerAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
